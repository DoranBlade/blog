---
title: "数据在内存中的存储"
date: 2017-12-30T16:30:54+08:00
tags: ["computer", "info"]
---
探究数据在内存中的存储
<!--more-->

### 字符
字符在内存中的存储与字符编码息息相关，现在有许多中字符编码方案(如ACSII,UTF-8)。鉴于ACSII的简洁性，下面都以ACSII编码为例。
ASCII编码是以一个字节作为编码单元的定长编码方案，其长度位256个字符。编码内所支持的每一个字符都对应数值，该数值按找无符号的方式编码成二进制数据，保存到内存中。字符"a"在ASCII编码中映射的值位97,97编码成二进制位01100001。

![](/assets/img/computer/binary08.png)

### 整数
整数分两种情况来分析，一种是无符号整数，另外一种有符号整数。在物理内存上不管是有符号还是无符号的整数，二进制数据的存储规范不会有不同的地方，有差别的是对于值的读取方式不同。为了便于阅读，下面都是以4位的长度来说明，不至于长度过长。

#### 无符号的整数
无符号的整数没有负值，读取值时按照最基本的取值方法即可。比如全部位为0时值位0，最低位为1时值位1，其他值在这基础上依次叠加即可。

``` java
// 0000
byte b1 = 0;
// 0101
byte b2 = 5; 
// 1111
byte b3= 255
```

#### 有符号整数
如果是有符号整数，则需要处理正数和负数的问题。有符号整数的取值方法与无符号整数是不一样的，大体上有两种取值方式：二进制补码计数法和余码计数法

二进制补码计数法较为通用一些,二进制补码计数法的大体规则如下

+ 所有位为0取值位0，依次递增取值也依次递增，如其他位为0最低位为1时，取值1
+ 所有位为1取值为-1,依次递减取值也依次递减，如其他位为1最低位为0时取值-1
+ 所以正数部分和负数部分各占一半，如8位的取值范围位-128~127

![](/assets/img/computer/binary04.png)

#### 二进制补码计数法
使用二进制补码计数法时，对于正数区域的取值与无符号整数一致。对于负数部分则需要使用补码规则对其进行取值，具体的流程是先计算出绝对值相等的整数部分的二进制码，然后利用补码规则计算出负数部分的二进制码。补码规则如下

+ 从对应正数二进制码的最低位开始，遇到第一个位码位1之时，位的数据均一样

![](/assets/img/computer/binary05.png)

+ 第一个位码为1之后的位数据均取反

![](/assets/img/computer/binary06.png)

对于设置值则与取值相反，负数部分先取绝对值相等的正数，然后生成该正数的二进制码，最后根据该二进制码做补码操作生成负数的二进制码。

#### 余码计数法
使用余码计数法取值时，最小值是所有位码为0，位码递增时取值也递增，最大值是所有位码为1。

![](/assets/img/computer/binary07.png)

余码计数法有一条能快速取值的规则：相对于无符号整数的取值，余码计数法的取值都需要减少1/2取值长度。例如上面示例中0000无符号取值位0，余码计数法时则需要减去2/16=8，最后取值-8。
